# Form implementation generated from reading ui file 'Search.ui'
#
# Created by: PyQt6 UI code generator 6.4.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt6 import QtCore, QtWidgets, QtGui
from PyQt6.QtCore import QProcess, Qt, QSortFilterProxyModel
from PyQt6.QtSql import QSqlRecord, QSqlRelation
from PyQt6.QtWidgets import QWidget, QPlainTextEdit, QMessageBox

from Models.ProductModel import ProductModel
from Models.SearchTermModel import SearchTermModel
from components.QSearchResult import QSearchResult


class _Ui_Search(object):

    def __init__(self, main_window):
        self.main_window = main_window
        self.p = None
        self.search_result_window = QSearchResult()
        self._translate = QtCore.QCoreApplication.translate

    def setupUi(self, Search):
        Search.setObjectName("Search")
        Search.resize(307, 43)
        # If false, the dialog won't delete itself on close.
        Search.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, False)
        self.verticalLayout = QtWidgets.QVBoxLayout(Search)

        self.verticalLayout.setObjectName("verticalLayout")

        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setSpacing(0)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.searchLabel = QtWidgets.QLabel(Search)
        self.searchLabel.setObjectName("searchLabel")
        self.horizontalLayout.addWidget(self.searchLabel)

        self.searchInput = QtWidgets.QLineEdit(Search)
        self.searchInput.setObjectName("searchInput")
        self.horizontalLayout.addWidget(self.searchInput)

        self.searchBtn = QtWidgets.QPushButton(Search)
        self.searchBtn.setObjectName("searchBtn")
        self.horizontalLayout.addWidget(self.searchBtn)

        self.searchInput.returnPressed.connect(self.searchBtn.click)
        self.searchBtn.clicked.connect(self.startSearch)

        self.text = QPlainTextEdit()
        self.text.setReadOnly(True)

        self.verticalLayout.addLayout(self.horizontalLayout)
        self.verticalLayout.addWidget(self.text)

        self.retranslateUi(Search)
        QtCore.QMetaObject.connectSlotsByName(Search)

    def retranslateUi(self, Search):
        Search.setWindowTitle(self._translate("Search", "Form"))
        self.searchLabel.setText(self._translate("Search", "Search"))
        self.searchInput.setPlaceholderText(self._translate("Search", "Enter product name"))
        self.searchBtn.setText(self._translate("Search", "Search"))

    def message(self, s):
        self.text.appendPlainText(s)

    def shouldLoadCachedData(self, searchTermRecord: QSqlRecord):

        search_date = searchTermRecord.indexOf('search_date')
        if searchTermRecord.value(search_date) is None:
            return False

        button = QMessageBox.question(self, "Reload Result confirmation",
                                      "This search term already exist and saved on \"{0}\", Do you want to reload "
                                      "search from database?".format(searchTermRecord.value(search_date)))
        return button == QMessageBox.StandardButton.Yes

    def startSearch(self):
        if self.searchInput.text().strip() == "":
            QMessageBox.warning(self, "Search Input Error", "Search input cannot be empty!")
            return

        searchTermModel = SearchTermModel()
        searchTermModel.setFilter("keyword = \"{}\"".format(self.searchInput.text()))
        if self.shouldLoadCachedData(searchTermModel.record(0)):
            self.show_result()
        else:
            self.searchBtn.setText(self._translate("Cancel Search", "Cancel Search"))
            self.p = QProcess()
            if self.p is not None:
                self.p.readyReadStandardOutput.connect(self.handle_stdout)
                self.p.readyReadStandardError.connect(self.handle_stderr)
                self.p.finished.connect(self.process_finished)  # Clean up once complete.
                self.p.start("python3", ["main.py", self.searchInput.text(), "-fsp"])

                self.searchBtn.clicked.disconnect(self.startSearch)
                self.searchBtn.clicked.connect(self.stop_process)

    def handle_stderr(self):
        if self.p is not None:
            data = self.p.readAllStandardError()
            stderr = bytes(data).decode("utf8")
            self.message(stderr)

    def handle_stdout(self):
        if self.p is not None:
            data = self.p.readAllStandardOutput()
            stdout = bytes(data).decode("utf8")
            self.message(stdout)

    def process_finished(self):
        self.message("Process finished.")
        self.p = None
        self.show_result()

    def stop_process(self):
        if self.p is not None:
            self.p.close()
            self.searchBtn.setText(self._translate("Search", "Search"))
            self.searchBtn.clicked.disconnect(self.stop_process)
            self.searchBtn.clicked.connect(self.startSearch)

    def show_result(self):
        if not self.search_result_window.isVisible():
            model = ProductModel()
            proxy = QSortFilterProxyModel()
            proxy.setSourceModel(model)
            if model.rowCount() > 0:
                self.search_result_window.setModel(proxy)
                self.search_result_window.showMaximized()

        else:
            self.search_result_window.hide()  # Close window.


class QSearch(QWidget, _Ui_Search):
    shit = QtCore.pyqtSignal()

    def __init__(self, *args, obj=None, **kwargs):
        super(QSearch, self).__init__(main_window=args[0])
        self.setupUi(self)

    def closeEvent(self, a0: QtGui.QCloseEvent) -> None:
        print("close")
        a0.accept()
